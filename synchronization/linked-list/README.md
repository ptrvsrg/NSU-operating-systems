# Односвязный список

## Задание

Реализуйте односвязный список, хранящий строки длиной менее 100 символов, у
которого с каждым элементом связан отдельный примитив синхронизации (за основу
можно взять реализацию списка, на котором построена очередь queue_t). Объявление
такого списка может выглядеть, например, так:

```C
typedef struct node_t {
    char            value[100];
    struct node_t*   next;
    pthread_mutex_t sync;
} node_t;

typedef struct _linked_list_t {
    node_t *first;
} linked_list_t;
```

Первый поток пробегает по всему хранилищу и ищет количество пар строк, идущих по
возрастанию длины. Как только достигнут конец списка, поток инкрементирует
глобальную переменную, в которой хранится, количество выполненных им итераций и
сразу начинает новый поиск.

Второй поток пробегает по всему хранилищу и ищет количество пар строк, идущих по
убыванию длины. Как только достигнут конец списка, поток инкрементирует
глобальную переменную, в которой хранится количество выполненных им итераций и
сразу начинает новый поиск.

Третий поток пробегает по всему хранилищу и ищет количество пар строк, имеющих
одинаковую длину. Как только достигнут конец списка, поток инкрементирует
глобальную переменную, в которой хранится количество выполненных им итераций и
сразу начинает новый поиск.

Запускается 3 потока, которые в непрерывном бесконечном цикле случайным образом
проверяют - требуется ли переставлять соседние элементы списка (не значения) и
выполняют перестановку. Каждая успешная попытка перестановки фиксируется в
соответствующей глобальной переменной-счетчике.

Используйте для синхронизации доступа к элементам списка спинлоки, мутексы и
блокировки чтения-записи. Понаблюдайте как изменяются (и изменяются ли) значения
переменных счетчиков и объясните результат. Проверьте для списков длины 100, 1000,
10000, 100000

При реализации обратите внимание на следующие пункты:

- продумайте ваше решение, чтобы избежать ошибок соревнования.
- необходимо блокировать все записи с данными которых производится работа.
- при перестановке записей списка, необходимо блокировать три записи.
- чтобы избежать мертвых блокировок, примитивы записей, более близких к началу
  списка, всегда захватывайте раньше